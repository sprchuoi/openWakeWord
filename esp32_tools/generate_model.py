#!/usr/bin/env python3
"""
Generate C model code for ESP32 integration.
Outputs only the trained model as C code for direct integration into existing ESP32 projects.
"""

import os
import sys
import argparse
import numpy as np
from pathlib import Path
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


def calculate_energy_threshold(audio_files, percentile=95):
    """
    Calculate energy threshold from voice samples.
    
    Args:
        audio_files: List of paths to WAV files
        percentile: Percentile for threshold (default 95)
        
    Returns:
        float: Calculated energy threshold
    """
    energies = []
    
    for audio_file in audio_files:
        try:
            # Read WAV file manually (avoiding dependencies)
            with open(audio_file, 'rb') as f:
                # Skip WAV header (44 bytes for standard WAV)
                f.seek(44)
                data = f.read()
                
                # Convert bytes to int16 samples
                samples = np.frombuffer(data, dtype=np.int16)
                
                # Calculate RMS energy
                energy = np.sqrt(np.mean(samples.astype(float) ** 2))
                energies.append(energy)
                
        except Exception as e:
            logger.warning(f"Failed to process {audio_file}: {e}")
            continue
    
    if not energies:
        logger.error("No valid audio files processed")
        return 0.0
    
    # Calculate threshold at specified percentile
    threshold = np.percentile(energies, percentile)
    
    logger.info(f"Calculated threshold: {threshold:.2f}")
    logger.info(f"Energy range: {np.min(energies):.2f} - {np.max(energies):.2f}")
    
    return threshold


def generate_c_model_code(wake_word, threshold, output_file):
    """
    Generate C code for wake word detection model.
    
    Args:
        wake_word: Wake word string
        threshold: Detection threshold value
        output_file: Output file path
    """
    
    # Sanitize wake word for C identifier
    model_name = wake_word.replace(' ', '_').replace('-', '_')
    model_name_upper = model_name.upper()
    
    c_code = f"""/*
 * Wake Word Detection Model: {wake_word}
 * Generated by openWakeWord ESP32 Training
 * 
 * This is a simple energy-based wake word detector optimized for ESP32.
 * It uses RMS energy calculation to detect voice activity.
 */

#ifndef {model_name_upper}_MODEL_H
#define {model_name_upper}_MODEL_H

#include <stdint.h>
#include <stdbool.h>
#include <math.h>

// Model Configuration
#define {model_name_upper}_THRESHOLD {threshold:.2f}f
#define {model_name_upper}_SAMPLE_RATE 16000
#define {model_name_upper}_FRAME_SIZE 1280  // 80ms at 16kHz

// Model state structure
typedef struct {{
    float threshold;
    float last_energy;
    uint32_t detection_count;
    uint32_t frame_count;
}} {model_name}_model_t;

// Initialize model
static inline void {model_name}_init({model_name}_model_t* model) {{
    model->threshold = {model_name_upper}_THRESHOLD;
    model->last_energy = 0.0f;
    model->detection_count = 0;
    model->frame_count = 0;
}}

// Calculate RMS energy of audio frame
static inline float {model_name}_calculate_energy(const int16_t* audio_data, size_t length) {{
    float sum = 0.0f;
    
    for (size_t i = 0; i < length; i++) {{
        float sample = (float)audio_data[i];
        sum += sample * sample;
    }}
    
    return sqrtf(sum / length);
}}

// Process audio frame and detect wake word
static inline bool {model_name}_predict({model_name}_model_t* model, 
                                        const int16_t* audio_data, 
                                        size_t length,
                                        float* confidence) {{
    // Calculate energy of current frame
    float energy = {model_name}_calculate_energy(audio_data, length);
    
    // Store energy for monitoring
    model->last_energy = energy;
    model->frame_count++;
    
    // Compare with threshold
    bool detected = (energy > model->threshold);
    
    // Calculate confidence score (0.0 to 1.0)
    *confidence = energy / (model->threshold * 2.0f);
    if (*confidence > 1.0f) *confidence = 1.0f;
    
    // Update detection counter
    if (detected) {{
        model->detection_count++;
    }}
    
    return detected;
}}

// Get model statistics
static inline void {model_name}_get_stats({model_name}_model_t* model,
                                          uint32_t* total_frames,
                                          uint32_t* total_detections,
                                          float* last_energy) {{
    *total_frames = model->frame_count;
    *total_detections = model->detection_count;
    *last_energy = model->last_energy;
}}

// Reset model statistics
static inline void {model_name}_reset_stats({model_name}_model_t* model) {{
    model->detection_count = 0;
    model->frame_count = 0;
    model->last_energy = 0.0f;
}}

// Adjust threshold dynamically
static inline void {model_name}_set_threshold({model_name}_model_t* model, float new_threshold) {{
    model->threshold = new_threshold;
}}

// Example usage:
/*
{model_name}_model_t model;
{model_name}_init(&model);

// In your audio processing loop:
int16_t audio_buffer[{model_name_upper}_FRAME_SIZE];
// ... fill audio_buffer with I2S data ...

float confidence;
if ({model_name}_predict(&model, audio_buffer, {model_name_upper}_FRAME_SIZE, &confidence)) {{
    printf("Wake word detected! Confidence: %.2f\\n", confidence);
}}
*/

#endif // {model_name_upper}_MODEL_H
"""
    
    # Write to file
    with open(output_file, 'w') as f:
        f.write(c_code)
    
    logger.info(f"Generated C model code: {output_file}")


def main():
    parser = argparse.ArgumentParser(
        description='Generate C model code for ESP32 wake word detection'
    )
    parser.add_argument(
        '--voice-dir',
        type=str,
        required=True,
        help='Directory containing voice sample WAV files'
    )
    parser.add_argument(
        '--wake-word',
        type=str,
        default='hey_assistant',
        help='Wake word name (default: hey_assistant)'
    )
    parser.add_argument(
        '--output',
        type=str,
        default='wake_word_model.h',
        help='Output C header file (default: wake_word_model.h)'
    )
    parser.add_argument(
        '--threshold-percentile',
        type=float,
        default=95.0,
        help='Percentile for threshold calculation (default: 95)'
    )
    
    args = parser.parse_args()
    
    # Validate input directory
    voice_dir = Path(args.voice_dir)
    if not voice_dir.exists():
        logger.error(f"Voice directory not found: {voice_dir}")
        sys.exit(1)
    
    # Find WAV files
    wav_files = list(voice_dir.glob('*.wav')) + list(voice_dir.glob('*.WAV'))
    if not wav_files:
        logger.error(f"No WAV files found in {voice_dir}")
        sys.exit(1)
    
    logger.info(f"Found {len(wav_files)} voice samples")
    
    # Calculate threshold from voice samples
    threshold = calculate_energy_threshold(wav_files, args.threshold_percentile)
    
    if threshold <= 0:
        logger.error("Failed to calculate threshold")
        sys.exit(1)
    
    # Generate C model code
    generate_c_model_code(args.wake_word, threshold, args.output)
    
    logger.info("Done!")
    logger.info(f"\nTo use this model in your ESP32 project:")
    logger.info(f"1. Copy {args.output} to your project include directory")
    logger.info(f"2. #include \"{args.output}\" in your source file")
    logger.info(f"3. Initialize model with {args.wake_word.replace(' ', '_')}_init()")
    logger.info(f"4. Call {args.wake_word.replace(' ', '_')}_predict() on each audio frame")


if __name__ == '__main__':
    main()
